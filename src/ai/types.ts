import { FunctionDeclarationSchema } from '@google/generative-ai'

/**
 * The assistant types that can fulfill the chat request
 */
export type AssistantType = 'openai' | 'gemini'

export interface FunctionDeclaration {
  /**
   * The description and purpose of the function. Model uses it to decide how and whether to call the function.
   */
  description: string

  /**
   * The name of the function to call
   */
  name: string

  /**
   * Describes the parameters to this function
   */
  parameters: FunctionDeclarationSchema

  /**
   * The API function to call at Gemini's choice
   */
  function: (parameters: any) => Promise<any>
}

/**
 * The user message prompt.
 */
export interface UserMessage {
  /**
   * The contents of the user message.
   */
  content: string

  /**
   * The type of the message, in this case is 'user'.
   */
  type: 'user'
}

/**
 * The assistant message response.
 */
export interface AssistantMessage {
  /**
   * The contents of the assistant message.
   */
  content: string

  /**
   * The type of the message, in this case is 'assistant'.
   */
  type: 'assistant'
}

/**
 * The assistant message that describes the function to call
 */
export interface FunctionCallMessage {
  calls: {
    /**
     * The arguments to call the function with, as generated by the model.
     */
    arguments: {}

    /**
     * A unique ID for the function to call in order to associate it with the function call response
     */
    id?: string

    /**
     * The name of the function to call.
     */
    name: string
  }[]

  /**
   * The contents of the assistant message.
   */
  content: string | null

  /**
   * The type of the message, in this case is 'functionCall'.
   */
  type: 'functionCall'
}

/**
 * The user message that describes the function call response
 */
export interface FunctionResponseMessage {
  /**
   * The response from the function call.
   */
  content: {}

  /**
   * The unique ID of the function call that this message is a response to.
   */
  id?: string

  /**
   * The n ame of the function that this message is a response to.
   */
  name: string

  /**
   * The type of the message, in this case is 'functionResponse'.
   */
  type: 'functionResponse'
}

/**
 * The message types that can be sent between the user and the assistant.
 */
export type Message =
  | UserMessage
  | AssistantMessage
  | FunctionCallMessage
  | FunctionResponseMessage

/**
 * A function to process a raw assistant message chunk being streamed to the
 * client
 */
export type ProcessAssistantMessageChunk = (
  assistantMessage: AssistantMessage,
) => AssistantMessage

/**
 * A function to process the raw messages from the assistant when the final
 * messages ready to be streamed to the client
 */
export type ProcessMessages = (rawMessages: Message[]) => Promise<Message[]>

export interface ChatOptions {
  /**
   * The introductory prompt/message from the assistant to start the chat
   */
  assistantPrompt: string

  /**
   * The desired assistant to fulfill the chat request
   */
  assistantType: AssistantType

  /**
   * The function declarations to use during the chat with the assistant
   */
  functionDeclarations: FunctionDeclaration[]

  /**
   * History of messages to pass to the assistant chat when sending the next
   * user message
   */
  history: Message[]

  /**
   * A function to process a raw assistant message chunk being streamed to the client
   */
  processAssistantMessageChunk?: ProcessAssistantMessageChunk

  /**
   * A function to process the raw messages from the assistant when the final
   * messages ready to be streamed to the client
   */
  processMessages?: ProcessMessages

  /**
   * The additional context to steer the behavior of the model
   */
  systemInstruction: string

  /**
   * The user prompt message to send with the next request
   */
  userPrompt?: string
}
